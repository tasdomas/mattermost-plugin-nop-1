/*
   The `generate` tool is used to generate a new empty implementation of any
   specified Interface.

   To run it, provide these parameters:
   -interface : {package}.{interface} - the interface to generate an empty implementation for.
   -pkg : name of the package for the generated output.
   -struct : name of the structure that will implement the interface.
   -output (optional): file to write the resulting output to.
*/
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"
)

func main() {
	// Log to stderr.
	log.SetOutput(os.Stderr)

	var outputDest string // File to write results to.
	flag.StringVar(&outputDest, "output", "-", "File to write output to.")
	var ifacePath string
	flag.StringVar(&ifacePath, "interface", "", "Interface to implement.")
	var outPkg string // Name of generated package.
	flag.StringVar(&outPkg, "pkg", "", "Generated package name.")
	var outStruct string // Name of generated struct.
	flag.StringVar(&outStruct, "struct", "", "Name of generated struct.")

	flag.Parse()

	pkg, iface, err := parseInterfacePath(ifacePath)
	if err != nil {
		log.Fatalf("could not parse interface path %q: %v", ifacePath, err)
	}

	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("%v", err)
	}

	p, err := getPackage(pkg, cwd)
	if err != nil {
		log.Fatalf("failed to get packaged: %v", err)
	}

	ifaceDecl, err := p.findInterfaceDeclaration(iface)
	if err != nil {
		log.Fatalf("failed to get interface %q: %v", iface, err)
	}

	methods, imports, err := p.getInterfaceMethods(ifaceDecl)
	if err != nil {
		log.Fatalf("failed to parse interface methods: %v", err)
	}

	srcBytes, err := p.generatePackage(outPkg, outStruct, methods, collectImports(imports))
	if err != nil {
		log.Fatalf("failed to generate package source: %v", err)
	}

	var output io.Writer
	if outputDest == "-" || outputDest == "" {
		output = os.Stdout
	} else {
		outputF, err := os.OpenFile(outputDest, os.O_RDWR|os.O_CREATE, 0644)
		if err != nil {
			log.Fatalf("failed to open output file %q: %v", outputDest, err)
		}
		defer outputF.Close()
		output = outputF
	}
	output.Write(srcBytes)
}

const pkgTmplRaw = `package {{.Pkg}}

// Code generated by ./tools/generate.go; DO NOT EDIT.

{{if .Imports}}
import (
  {{range .Imports}}
  {{- if .Name }}
  {{ .Name }} "{{ .Path }}"
  {{- else -}}
  "{{ .Path }}"
  {{- end }}
  {{ end}}
)
{{end}}

type {{.Recv}} struct {}

{{range .Methods}}
  func ({{$.Recv}}) {{.Name -}}
    ({{range .Args}}{{.Name}} {{.Type}}, {{end}}) ({{range .Results}}{{.Name}} {{.Type}}, {{end}}) {
    return
}
{{end}}
`

var pkgTmpl = template.Must(template.New("pkg").Parse(pkgTmplRaw))

// pkg is used to bundle data retrieved when processing a go package
type pkg struct {
	name    string
	tree    *ast.File
	fset    *token.FileSet
	imports map[string]string
}

// getPackage loads and preprocessed the package.
func getPackage(pkgId string, dir string) (*pkg, error) {
	p, err := build.Default.Import(pkgId, dir, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to import package %q: %w", pkgId, err)
	}

	fset := token.NewFileSet()

	// Parse package directory.
	pkgs, err := parser.ParseDir(fset, p.Dir, nil, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to parse package directory %q: %w", p.Dir, err)
	}

	// Get package AST.
	pkgAst, ok := pkgs[p.Name]
	if !ok {
		return nil, fmt.Errorf("AST for package %q not loaded", pkgId)
	}

	// Combine package file ASTs.
	f := ast.MergePackageFiles(pkgAst, 0)

	// Gather import relationships.
	imports := packageImports(f)
	imports[pkgAlias(pkgId)] = pkgId // Add the package being exemined.
	// Combined AST of all package files.
	return &pkg{name: p.Name, tree: f, fset: fset, imports: imports}, nil
}

func packageImports(f *ast.File) map[string]string {
	result := make(map[string]string)
	for _, imp := range f.Imports {
		pth := imp.Path.Value[1 : len(imp.Path.Value)-1]
		n := ""
		if imp.Name != nil {
			n = imp.Name.Name
		} else {
			n = pkgAlias(pth)
		}
		if v, ok := result[n]; ok && v != pth {
			log.Printf("(WARN) import %q conflicts with %q", v, pth)
			continue
		}
		result[n] = pth
	}
	return result
}

// pkgAlias gets the package name from full path.
func pkgAlias(pth string) string {
	i := strings.LastIndex(pth, "/")
	return pth[i+1:]
}

// collectImports parses the map of imports used and returns a
// sorted slice of `importData` structs.
func collectImports(imports map[string]string) []importData {
	result := make([]importData, 0, len(imports))
	for name, importPath := range imports {
		if name == pkgAlias(importPath) {
			result = append(result, importData{Path: importPath})
		} else {
			result = append(result, importData{Name: name, Path: importPath})
		}
	}
	sort.Sort(sortedImports(result))
	return result
}

// findInterfaceDeclaration extracts the AST for the interface declaration.
func (p pkg) findInterfaceDeclaration(interfaceName string) (*ast.InterfaceType, error) {
	for _, decl := range p.tree.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			continue
		}
		for _, spec := range decl.Specs {
			spec, ok := spec.(*ast.TypeSpec)
			if !ok || spec.Name.Name != interfaceName {
				continue
			}
			specType, ok := spec.Type.(*ast.InterfaceType)
			if !ok {
				return nil, fmt.Errorf("%q is not an interface", interfaceName)
			}
			return specType, nil
		}
	}
	return nil, fmt.Errorf("declaration of interface %q not found", interfaceName)
}

// getInterfaceMethods returns a list of methods defined by the interface
// along with any imports required by the parameters or results of those methods.
func (p pkg) getInterfaceMethods(i *ast.InterfaceType) ([]method, map[string]string, error) {
	methods := make([]method, 0, len(i.Methods.List))
	imports := make(map[string]string)
	for _, fn := range i.Methods.List {
		m := method{
			Name: fn.Names[0].Name,
		}
		fnType, ok := fn.Type.(*ast.FuncType)
		if !ok {
			return nil, nil, fmt.Errorf("could not cast function node")
		}
		params, paramImports := p.getMethodParams(fnType)
		for n, i := range paramImports {
			imports[n] = i
		}
		results, resultImports := p.getMethodResults(fnType)
		for n, i := range resultImports {
			imports[n] = i
		}

		m.Args = params
		m.Results = results
		methods = append(methods, m)
	}
	return methods, imports, nil
}

// getMethodParams returns a list of parameters used by the method along
// with a map of any required imports.
func (p pkg) getMethodParams(m *ast.FuncType) ([]arg, map[string]string) {
	args := []arg{}
	imports := make(map[string]string)
	for _, argument := range m.Params.List {
		t, typeImport := p.paramType(argument.Type)
		for name, imp := range typeImport {
			imports[name] = imp
		}
		for _, n := range argument.Names {
			name := n.Name
			if name == "" {
				name = "_" // default empty name to `_`
			}
			args = append(args, arg{Name: name, Type: t})
		}
	}
	return args, imports
}

// getMethodResults returns a list of the method's return values along
// with a map of any required imports.
func (p pkg) getMethodResults(m *ast.FuncType) ([]arg, map[string]string) {
	results := []arg{}
	imports := make(map[string]string)
	if m.Results == nil {
		return results, nil
	}
	for _, result := range m.Results.List {
		t, typeImports := p.paramType(result.Type)
		for name, imp := range typeImports {
			imports[name] = imp
		}
		var name string
		if len(result.Names) == 0 || result.Names[0].Name == "" {
			name = "_" // default empty name to `_`
		} else {
			name = result.Names[0].Name
		}
		results = append(results, arg{Name: name, Type: t})
	}
	return results, imports
}

// paramType returns the type of the parameter and required import.
func (p pkg) paramType(e ast.Expr) (string, map[string]string) {
	// Find any types defined in the same package
	// and turn them into selector expressions (`pkg.type`).
	var impName string
	ast.Inspect(e, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.Ident:
			if n.IsExported() {
				n.Name = p.name + "." + n.Name
				impName = p.name
			}
		case *ast.SelectorExpr:
			i, ok := n.X.(*ast.Ident)
			if ok {
				impName = i.Name
			}
			return false
		}
		return true
	})

	var buf bytes.Buffer
	printer.Fprint(&buf, p.fset, e)

	if impName != "" {
		return buf.String(), map[string]string{impName: p.imports[impName]}
	}
	return buf.String(), nil
}

func (p pkg) generatePackage(pkgName, receiver string, methods []method, imports []importData) ([]byte, error) {
	var buf bytes.Buffer
	pkgTmpl.Execute(&buf,
		struct {
			Recv    string
			Pkg     string
			Methods []method
			Imports []importData
		}{
			Recv:    receiver,
			Pkg:     pkgName,
			Methods: methods,
			Imports: imports,
		})

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}

func parseInterfacePath(raw string) (string, string, error) {
	if strings.Index(raw, "/") == -1 {
		return "", "", fmt.Errorf("expected package path")
	}
	dot := strings.LastIndex(raw, ".")
	if dot == -1 {
		return "", "", fmt.Errorf("expected interface type to be part of path")
	}
	return raw[:dot], raw[dot+1:], nil
}

type method struct {
	Name    string
	Args    []arg
	Results []arg
}

type arg struct {
	Name string
	Type string
}

type importData struct {
	Name string
	Path string
}

// sortedImports implements the `sort.Interface`.
// Imports are currently sorted without separating them into
// core, 3rd party and local import groups.
type sortedImports []importData

// Len implements part of the `sort.Interface`.
func (s sortedImports) Len() int { return len(s) }

// Less implements part of the `sort.Interface`.
func (s sortedImports) Less(i, j int) bool {
	return s[i].Path < s[j].Path
}

// Swap implements part of the `sort.Interface`.
func (s sortedImports) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
